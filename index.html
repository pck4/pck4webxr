<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>Quest3 AR 벽돌깨기 (통합 파일)</title>
    <!-- A-Frame 라이브러리 -->
    <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
    <!-- aframe-physics-system (Cannon.js 기반) -->
    <script src="https://cdn.jsdelivr.net/npm/aframe-physics-system@4.0.1/dist/aframe-physics-system.min.js"></script>
    <style>
      body { margin: 0; padding: 0; overflow: hidden; }
    </style>
  </head>
  <body>
    <!-- immersive-ar 모드, local-floor 참조, 패스스루 AR 구현 -->
    <a-scene 
      xr="mode: 'immersive-ar'; referenceSpaceType: 'local-floor';" 
      physics="gravity: 0 0 0" 
      embedded 
      renderer="logarithmicDepthBuffer: true;" 
      vr-mode-ui="enabled: false">
      
      <!-- 게임 전체를 감싸는 루트 엔티티: 바닥(hit test) 인식 -->
      <a-entity id="game-root" floor-detector>
      
        <!-- 발판(Paddle): static-body, 컨트롤러 입력으로 움직임 -->
        <a-box id="player-bar"
          paddle-controller
          static-body
          position="0 0.2 -3"
          width="1.2" height="0.2" depth="0.2"
          color="#4CC3D9">
        </a-box>
        
        <!-- 공(Ball): dynamic-body로 물리 효과 적용, 초기 발사 -->
        <a-sphere id="ball"
          dynamic-body="mass: 1; shape: sphere; restitution: 1.0;"
          ball-collision
          ball-launcher
          position="0 0.5 -3"
          radius="0.1"
          color="#EF2D5E">
        </a-sphere>
        
        <!-- 벽돌들(Bricks): static-body -->
        <a-box class="brick" static-body position="-1 1.8 -3" width="0.4" height="0.2" depth="0.2" color="#FFC65D"></a-box>
        <a-box class="brick" static-body position="0 1.8 -3"  width="0.4" height="0.2" depth="0.2" color="#7BC8A4"></a-box>
        <a-box class="brick" static-body position="1 1.8 -3"  width="0.4" height="0.2" depth="0.2" color="#FFC65D"></a-box>
      
      </a-entity>
      
      <!-- 카메라: AR 환경에서 헤드셋 뷰 반영 -->
      <a-camera position="0 1.6 0"></a-camera>
      
      <!-- 오른손 컨트롤러: laser-controls로 모델링 -->
      <a-entity id="right-controller" laser-controls="hand: right"></a-entity>
      
    </a-scene>
    
    <!-- JavaScript 코드를 index.html 내부에 포함 -->
    <script>
      // 1. 바닥 자동 인식을 위한 floor-detector 컴포넌트 (WebXR Hit Test API 활용)
      AFRAME.registerComponent('floor-detector', {
        init: function () {
          this.hitTestSource = null;
          this.refSpace = null;
          this.viewerSpace = null;
          this.session = null;
          
          this.el.sceneEl.addEventListener('enter-vr', () => {
            this.session = this.el.sceneEl.renderer.xr.getSession();
            if (this.session && this.session.isImmersiveAr) {
              this.session.requestReferenceSpace('viewer').then((space) => {
                this.viewerSpace = space;
                return this.session.requestHitTestSource({ space: this.viewerSpace });
              }).then((source) => {
                this.hitTestSource = source;
              });
              this.session.requestReferenceSpace('local-floor').then((refSpace) => {
                this.refSpace = refSpace;
              });
            }
          });
          
          this.el.sceneEl.addEventListener('exit-vr', () => {
            this.hitTestSource = null;
            this.refSpace = null;
            this.viewerSpace = null;
            this.session = null;
          });
        },
        tick: function () {
          if (!this.hitTestSource || !this.session || !this.refSpace) { return; }
          const xrFrame = this.el.sceneEl.frame;
          if (!xrFrame) { return; }
          const hitTestResults = xrFrame.getHitTestResults(this.hitTestSource);
          if (hitTestResults.length > 0) {
            const hit = hitTestResults[0];
            const pose = hit.getPose(this.refSpace);
            if (pose) {
              // 게임 루트 엔티티의 위치를 실제 바닥 위치로 업데이트
              this.el.object3D.position.set(
                pose.transform.position.x,
                pose.transform.position.y,
                pose.transform.position.z
              );
            }
          }
        }
      });
      
      // 2. 공 충돌 판정 및 효과 처리 (충돌 시 벽돌 제거)
      AFRAME.registerComponent('ball-collision', {
        init: function () {
          this.el.addEventListener('collide', (e) => {
            const collidedEl = e.detail.body.el;
            if (collidedEl && collidedEl.classList.contains('brick')) {
              collidedEl.parentNode.removeChild(collidedEl);
              console.log('Brick destroyed!');
            }
          });
        }
      });
      
      // 3. ball-launcher 컴포넌트: 물리 바디에 초기 속도 부여 (1초 후 실행)
      AFRAME.registerComponent('ball-launcher', {
        init: function () {
          setTimeout(() => {
            if (this.el.body) {
              this.el.body.velocity.set(0.5, 0.5, 0);
            }
          }, 1000);
        }
      });
      
      // 4. paddle-controller 컴포넌트: 오른손 컨트롤러의 트리거가 눌리면 컨트롤러의 x좌표를 발판에 반영
      AFRAME.registerComponent('paddle-controller', {
        schema: {
          controllerId: { default: '#right-controller' }
        },
        init: function () {
          this.controller = document.querySelector(this.data.controllerId);
        },
        tick: function () {
          if (!this.controller) { return; }
          const tracked = this.controller.components['tracked-controls'];
          if (!tracked || !tracked.controller) { return; }
          const gamepad = tracked.controller;
          // 보통 버튼 0(트리거)이 눌렸을 때 발판 이동
          if (gamepad.buttons[0] && gamepad.buttons[0].pressed) {
            const controllerPos = new THREE.Vector3();
            this.controller.object3D.getWorldPosition(controllerPos);
            this.el.object3D.position.x = controllerPos.x;
            if (this.el.body) {
              this.el.body.position.x = controllerPos.x;
              this.el.body.velocity.x = 0;
            }
          }
        }
      });
    </script>
  </body>
</html>
