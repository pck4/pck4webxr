<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>스마트폰 웹앱 벽돌깨기</title>
    <!-- A-Frame 라이브러리 (최신 안정 버전) -->
    <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
    <style>
      body { margin: 0; padding: 0; overflow: hidden; }
    </style>
  </head>
  <body>
    <!-- 일반 3D 씬: AR 기능 없이 단순한 벽돌깨기 게임 -->
    <a-scene id="scene" embedded>
      <!-- 카메라: 기본 위치 설정 -->
      <a-camera position="0 1.6 0"></a-camera>
      
      <!-- 발판(Paddle): 터치로 좌우 이동 -->
      <a-box id="paddle" position="0 0.5 -3" width="1.2" height="0.2" depth="0.2" color="#4CC3D9" paddle-mover></a-box>
      
      <!-- 공(Ball): 움직이며 충돌 판정 -->
      <a-sphere id="ball" position="0 1 -3" radius="0.1" color="#EF2D5E" ball-controller></a-sphere>
      
      <!-- 벽돌들(Bricks): 여러 개 배치 (필요에 따라 동적 생성 가능) -->
      <a-box class="brick" position="-1 2 -3" width="0.4" height="0.2" depth="0.2" color="#FFC65D"></a-box>
      <a-box class="brick" position="0 2 -3"  width="0.4" height="0.2" depth="0.2" color="#7BC8A4"></a-box>
      <a-box class="brick" position="1 2 -3"  width="0.4" height="0.2" depth="0.2" color="#FFC65D"></a-box>
    </a-scene>

    <!-- 인라인 JavaScript: 스마트폰용 터치 조작 및 게임 로직 -->
    <script>
      // 발판(paddle)을 터치 이벤트로 좌우 이동시키는 컴포넌트
      AFRAME.registerComponent('paddle-mover', {
        init: function () {
          const sceneEl = this.el.sceneEl;
          // canvas가 준비된 후 터치 이벤트 등록 (passive:false로 등록)
          sceneEl.canvas.addEventListener('touchmove', evt => {
            evt.preventDefault();
            const touch = evt.touches[0];
            const canvas = sceneEl.canvas;
            // canvas의 폭(clientWidth) 기준 터치 위치 정규화: -1 ~ 1
            const normalizedX = (touch.clientX / canvas.clientWidth) * 2 - 1;
            // 정규화된 값을 발판의 이동 범위(여기서는 -1.5 ~ 1.5)로 매핑
            const newX = normalizedX * 1.5;
            this.el.object3D.position.x = newX;
          }, {passive: false});
        }
      });

      // 공(ball)의 이동과 충돌 판정을 처리하는 컴포넌트
      AFRAME.registerComponent('ball-controller', {
        schema: {
          vx: { type: 'number', default: 0.02 },  // x축 초기 속도
          vy: { type: 'number', default: 0.02 }   // y축 초기 속도
        },
        init: function () {
          // 초기 속도 벡터 생성
          this.velocity = new THREE.Vector3(this.data.vx, this.data.vy, 0);
        },
        tick: function (time, delta) {
          const ball = this.el.object3D;
          // delta 보정(16ms 기준)하여 속도 벡터만큼 이동
          ball.position.add(this.velocity.clone().multiplyScalar(delta / 16));
          
          // 좌우 벽 충돌 (x: -1.5 ~ 1.5)
          if (ball.position.x > 1.5 || ball.position.x < -1.5) {
            this.velocity.x *= -1;
          }
          // 천장 충돌 (y=3)
          if (ball.position.y > 3) {
            this.velocity.y *= -1;
          }
          // 바닥으로 떨어지면 재시작
          if (ball.position.y < 0) {
            ball.position.set(0, 1, -3);
            this.velocity.set(this.data.vx, this.data.vy, 0);
          }
          
          // 발판과의 충돌 판정 (단순 bounding box 방식)
          const paddleEl = document.querySelector('#paddle');
          const paddlePos = paddleEl.object3D.position;
          if (Math.abs(ball.position.x - paddlePos.x) < 0.8 &&
              Math.abs(ball.position.y - paddlePos.y) < 0.3 &&
              Math.abs(ball.position.z - paddlePos.z) < 0.3) {
            // 발판과 충돌 시 y축 속도를 반전(위로 튕겨냄)
            this.velocity.y = Math.abs(this.velocity.y);
          }
          
          // 벽돌과의 충돌 판정 (각 벽돌에 대해 간단히 계산)
          const bricks = document.querySelectorAll('.brick');
          bricks.forEach(brick => {
            if (!brick.getAttribute('visible')) return;
            const brickPos = brick.object3D.position;
            if (Math.abs(ball.position.x - brickPos.x) < 0.3 &&
                Math.abs(ball.position.y - brickPos.y) < 0.3 &&
                Math.abs(ball.position.z - brickPos.z) < 0.3) {
              // 충돌 시 벽돌을 보이지 않도록 처리 및 공의 y축 반전
              brick.setAttribute('visible', 'false');
              this.velocity.y *= -1;
            }
          });
        }
      });
    </script>
  </body>
</html>
